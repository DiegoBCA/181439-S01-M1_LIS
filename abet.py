# -*- coding: utf-8 -*-
"""Abet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jV9FqZLrOesc0e7MTHwc7kLml6s0T2bv
"""

import re
import sys

# ================== 1. ANALIZADOR LÉXICO (FINAL) ==================

class AnalizadorLexico:
    def __init__(self):
        self.palabras_reservadas = {
            'int': 'TIPO_INT', 'bool': 'TIPO_BOOL', 'if': 'IF',
            'else': 'ELSE', 'while': 'WHILE', 'print': 'PRINT',
            'true': 'TRUE', 'false': 'FALSE'
        }

        self.mapa_tokens = {
            '&&': 'OP_AND', '||': 'OP_OR',
            '==': 'OP_REL', '!=': 'OP_REL', '<=': 'OP_REL', '>=': 'OP_REL',
            '<': 'OP_REL', '>': 'OP_REL',
            '!': 'OP_NOT',
            '+': 'OP_ARIT', '-': 'OP_ARIT', '*': 'OP_ARIT', '/': 'OP_ARIT',
            '=': 'ASIGN',
            ';': 'PUNTOCOMA', ',': 'COMA',
            '(': 'LPAREN', ')': 'RPAREN',
            '{': 'LBRACE', '}': 'RBRACE'
        }

        # Grupos de no captura (?:...) aplicados para evitar problemas de índice
        rules = [
            (r'\s+', None),
            (r'//.*', None),
            (r'(?:==|<=|>=|!=|&&|\|\|)', 'OPERADOR_MULTI'),
            (r'\b(?:int|bool|if|else|while|print|true|false)\b', 'KEYWORD'),
            (r'\b[0-9]+\b', 'NUMERO_ENTERO'),
            (r'\b[a-zA-Z_][a-zA-Z0-9_]*\b', 'ID'),
            (r'[=<>\+\-\*/!;,(){}]', 'OPERADOR_SIMPLE')
        ]

        self.patron_token = re.compile('|'.join(f'({rule})' for rule, _ in rules))
        self.tipos_token = [tipo for _, tipo in rules]

    def tokenizar(self, codigo):
        tokens = []
        linea = 1

        for match in self.patron_token.finditer(codigo):
            tipo = None
            valor = match.group(0)

            # ********** CORRECCIÓN DEL ÍNDICE APLICADA (i + 1) **********
            for i, tipo_sub in enumerate(self.tipos_token):
                if match.group(i + 1): # <-- CAMBIO CLAVE
                    tipo = tipo_sub
                    break
            # ************************************************************

            if tipo is None:
                if '\n' in valor:
                    linea += valor.count('\n')
                continue

            tipo_token = None
            if tipo == 'KEYWORD':
                tipo_token = self.palabras_reservadas.get(valor)
            elif tipo == 'ID':
                tipo_token = 'ID'
            elif tipo == 'NUMERO_ENTERO':
                tipo_token = 'LITERAL_ENTERO'
            elif tipo == 'OPERADOR_MULTI' or tipo == 'OPERADOR_SIMPLE':
                tipo_token = self.mapa_tokens.get(valor)

            if tipo_token is None:
                print(f"Advertencia Léxica en línea {linea}: Token no reconocido '{valor}' (tipo {tipo}) ignorado.")
                continue

            tokens.append(Token(tipo_token, valor, linea))

        tokens.append(Token('EOF', 'EOF', linea))
        return tokens

class Token:
    def __init__(self, tipo, valor, linea):
        self.tipo = tipo
        self.valor = valor
        self.linea = linea
    def __repr__(self):
        return f"Token({self.tipo}, '{self.valor}')"

print("✅ Célula 1: Analizador Léxico corregido (IndexError arreglado).")

# ================== 2. CLASES AST (Diego Bed) ==================

class ASTNode: pass
class Program(ASTNode):
    def __init__(self, statements):
        self.statements = statements

class Statement(ASTNode): pass
class Expression(ASTNode): pass

class VarDecl(Statement):
    def __init__(self, tipo_token, var_token):
        self.tipo_token = tipo_token
        self.var_token = var_token

class Assignment(Statement):
    def __init__(self, var_token, expression):
        self.var_token = var_token
        self.expression = expression

class IfStatement(Statement):
    def __init__(self, condition, true_branch, false_branch):
        self.condition = condition
        self.true_branch = true_branch
        self.false_branch = false_branch

class WhileStatement(Statement):
    def __init__(self, condition, body):
        self.condition = condition
        self.body = body

class PrintStatement(Statement):
    def __init__(self, expression):
        self.expression = expression

class Block(Statement):
    def __init__(self, statements):
        self.statements = statements

class BinaryOp(Expression):
    def __init__(self, left, op_token, right):
        self.left = left
        self.op_token = op_token
        self.right = right

class UnaryOp(Expression):
    def __init__(self, op_token, right):
        self.op_token = op_token
        self.right = right

class Literal(Expression):
    def __init__(self, token):
        self.token = token

class Variable(Expression):
    def __init__(self, token):
        self.token = token

print("✅ Célula 2: Clases del AST listas.")

# ================== 3. ANALIZADOR SINTÁCTICO (Diego Bed) ==================

class AnalizadorSintactico:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.token_actual = self.tokens[self.pos]

    def _error(self, mensaje):
        print(f"Error Sintáctico en línea {self.token_actual.linea}: {mensaje}. Se encontró: {self.token_actual.tipo}")
        sys.exit(1) # Termina el programa

    def _avanzar(self):
        self.pos += 1
        if self.pos < len(self.tokens):
            self.token_actual = self.tokens[self.pos]

    def _consumir(self, tipo_esperado):
        if self.token_actual.tipo == tipo_esperado:
            self._avanzar()
        else:
            self._error(f"Se esperaba '{tipo_esperado}'")

    def parse(self):
        statements = []
        while self.token_actual.tipo != 'EOF':
            statements.append(self.parse_statement())
        return Program(statements)

    def parse_statement(self):
        if self.token_actual.tipo in ('TIPO_INT', 'TIPO_BOOL'):
            return self.parse_var_declaration()
        elif self.token_actual.tipo == 'IF':
            return self.parse_if_statement()
        elif self.token_actual.tipo == 'WHILE':
            return self.parse_while_statement()
        elif self.token_actual.tipo == 'PRINT':
            return self.parse_print_statement()
        elif self.token_actual.tipo == 'ID':
            return self.parse_assignment_statement()
        elif self.token_actual.tipo == 'LBRACE':
            return self.parse_block()
        else:
            self._error("Declaración no válida")

    def parse_block(self):
        statements = []
        self._consumir('LBRACE')
        while self.token_actual.tipo != 'RBRACE' and self.token_actual.tipo != 'EOF':
            statements.append(self.parse_statement())
        self._consumir('RBRACE')
        return Block(statements)

    def parse_var_declaration(self):
        tipo_token = self.token_actual
        self._avanzar()
        var_token = self.token_actual
        self._consumir('ID')
        self._consumir('PUNTOCOMA')
        return VarDecl(tipo_token, var_token)

    def parse_assignment_statement(self):
        var_token = self.token_actual
        self._consumir('ID')
        self._consumir('ASIGN')
        expr = self.parse_expression()
        self._consumir('PUNTOCOMA')
        return Assignment(var_token, expr)

    def parse_if_statement(self):
        self._consumir('IF')
        self._consumir('LPAREN')
        condicion = self.parse_expression()
        self._consumir('RPAREN')
        true_branch = self.parse_statement()

        false_branch = None
        if self.token_actual.tipo == 'ELSE':
            self._avanzar()
            false_branch = self.parse_statement()

        return IfStatement(condicion, true_branch, false_branch)

    def parse_while_statement(self):
        self._consumir('WHILE')
        self._consumir('LPAREN')
        condicion = self.parse_expression()
        self._consumir('RPAREN')
        body = self.parse_statement()
        return WhileStatement(condicion, body)

    def parse_print_statement(self):
        self._consumir('PRINT')
        self._consumir('LPAREN')
        expr = self.parse_expression()
        self._consumir('RPAREN')
        self._consumir('PUNTOCOMA')
        return PrintStatement(expr)

    def parse_expression(self):
        nodo = self.parse_primary_expression()
        while self.token_actual.tipo in ('OP_ARIT', 'OP_REL', 'OP_AND', 'OP_OR'):
            op_token = self.token_actual
            self._avanzar()
            right = self.parse_primary_expression()
            nodo = BinaryOp(left=nodo, op_token=op_token, right=right)
        return nodo

    def parse_primary_expression(self):
        token = self.token_actual
        if token.tipo == 'LITERAL_ENTERO':
            self._avanzar()
            return Literal(token)
        elif token.tipo in ('TRUE', 'FALSE'):
            self._avanzar()
            return Literal(token)
        elif token.tipo == 'ID':
            self._avanzar()
            return Variable(token)
        elif token.tipo == 'LPAREN':
            self._avanzar()
            nodo = self.parse_expression()
            self._consumir('RPAREN')
            return nodo
        else:
            self._error("Expresión primaria no válida (se esperaba número, ID, 'true'/'false' o '(')")

print("✅ Célula 3: Analizador Sintáctico (Parser) listo.")

# ================== 4. STUBS (SIMULACROS) Y CÓDIGO DE COMPAÑEROS ==================

class AnalizadorSemanticoAST:
    """
    [STUB PARA EL EQUIPO SEMÁNTICO]
    Finge ser el Analizador Semántico. Acepta el AST.
    """
    def __init__(self):
        print("[STUB Semántico] Iniciado (Modo AST).")
        self.tabla_simbolos = {}

    def analizar(self, ast_node):
        if not isinstance(ast_node, Program):
             print(f"[STUB Semántico] Error: Se esperaba un nodo 'Program', se recibió {type(ast_node)}")
             return
        print("[STUB Semántico] 'Analizando' el nodo raíz del AST (Program)...")
        print("[STUB Semántico] Análisis simulado completado (sin errores).")
        pass

class GeneradorDeCodigo:
    """
    [STUB PARA EL ROL 2 - CodeGen]
    Finge ser el Generador de Código. Acepta el AST y produce TAC falso.
    """
    def __init__(self):
        print("[STUB CodeGen] Iniciado.")

    def generar(self, ast_node):
        print(f"[STUB CodeGen] 'Generando' TAC desde el AST...")
        tac_falso = "; --- Código TAC Falso (Generado por STUB) ---\n"
        tac_falso += "t1 := 10\n"
        tac_falso += "t2 := 5\n"
        tac_falso += "if t1 > t2 goto L1\n"
        return tac_falso

# ================== GENERADOR TAC ==================

class TACGenerator:
    def __init__(self):
        self.temp_counter = 0
        self.label_counter = 0
        self.instructions = []
    # Los temp sirven para las variables temporales donde se guarda la informacion
    # de operaciones binarias
    def new_temp(self):
        """Genera un nuevo nombre de temporal"""
        self.temp_counter += 1
        return f"t{self.temp_counter}"

    # Las etiquetas indican saltos de linea y cambian el flujo del código
    def new_label(self):
        """Genera una nueva etiqueta"""
        self.label_counter += 1
        return f"L{self.label_counter}"

    def emit(self, instruction):
        """Añade una instrucción TAC a la lista"""
        self.instructions.append(instruction)

    def visit(self, node):
        """Método principal que visita cada tipo de nodo"""
        method_name = f'visit_{type(node).__name__}' # Busca el método del tipo que reciba
        method = getattr(self, method_name, self.visit_unknown) # Ejecuta su método dependiendo del tipo
        return method(node)

    def visit_unknown(self, node):
        raise Exception(f"Método visit no implementado para {type(node).__name__}")

    # ========== MÉTODOS del AST ==========

    def visit_Program(self, node):
        for statement in node.statements:
            self.visit(statement)

    # Para valores enteros
    def visit_Literal(self, node):
        return node.token.valor
    # Para variables
    def visit_Variable(self, node):
        return node.token.valor

    # Para operaciones binarias
    def visit_BinaryOp(self, node):
        # Visita primero sus nodos hijos
        left_value = self.visit(node.left)
        right_value = self.visit(node.right)
        temp = self.new_temp() # obtiene una variable temporal para luego almacenarla
        self.emit(f"{temp} := {left_value} {node.op_token.valor} {right_value}")
        return temp
    # Para asignación x = a + b
    def visit_Assignment(self, node):
        # Checa el target (x)
        target = node.var_token.valor
        # Checa el valor de la asignación (a + b)
        value = self.visit(node.expression)
        self.emit(f"{target} := {value}")
        return target
    # Para ifs
    def visit_IfStatement(self, node):
        # Visita primero la condición
        condition = self.visit(node.condition)
        # Declara label del else, importante para marcar el flujo
        label_else = self.new_label()


        self.emit(f"if {condition} == false goto {label_else}")
        #Visita la condición que se cumple
        self.visit(node.true_branch)

        if node.false_branch:# Si hay sentencia de else no vacía
            label_end = self.new_label() # Declara nuevo label para el salto al final de la condición
            self.emit(f"goto {label_end}")
            self.emit(f"{label_else}:") # Inicio del bloque else
            self.visit(node.false_branch)
            self.emit(f"{label_end}:")
        else:
            self.emit(f"{label_else}:")

    # Para el while
    def visit_WhileStatement(self, node):
        # Declaración de labels primero para el flujo de información
        label_start = self.new_label()
        label_end = self.new_label()

        self.emit(f"{label_start}:")
        # Procesar la condición
        condition = self.visit(node.condition)
        self.emit(f"if {condition} == false goto {label_end}")
        # Visitar el contenido del while
        self.visit(node.body)
        self.emit(f"goto {label_start}")
        self.emit(f"{label_end}:")

    # Para los bloques de código extensos (de if y while)
    def visit_Block(self, node):
        # Por cada uno de las lineas de código, se visitan
        for statement in node.statements:
            self.visit(statement)

    # Para el print
    def visit_PrintStatement(self, node):
        value = self.visit(node.expression)
        self.emit(f"print {value}")

    def visit_VarDecl(self, node):
        # Las declaraciones no generan código TAC ejecutable
        self.emit(f"# Declaración: {node.tipo_token.valor} {node.var_token.valor}")

    def generate(self, ast):
        self.instructions = []
        self.temp_counter = 0
        self.label_counter = 0
        self.visit(ast)
        return self.instructions

class GeneradorDeCodigo:
    def __init__(self):
        print("[CodeGen] Iniciado (Generador TAC Real).")
        self.generator = TACGenerator()

    def generar(self, ast_node):
        print("[CodeGen] Generando TAC desde el AST...")
        instructions = self.generator.generate(ast_node)

        # Convertir a string para guardar en archivo
        tac_code = "\n".join(instructions)
        return tac_code

# ---
# [CÓDIGO DE TU COMPAÑERO - ROL 3]
# ---
class MaquinaTAC:
    def __init__(self):
        print("[MaquinaTAC] (Rol 3) Iniciada.")
        self.mem = {}

    def ejecutar(self, instrucciones):
        print(f"[MaquinaTAC] Ejecutando {len(instrucciones)} instrucciones...")
        for inst in instrucciones:
            op = inst[0]

            if op == 'assign':
                _, dest, val = inst
                self.mem[dest] = val
                print(f"[MaquinaTAC] {dest} = {val}")

            # (Se omiten los otros 'elif' por brevedad, pero aquí van)
            # ...

            else:
                 print(f"[MaquinaTAC] Operación desconocida: {op}")


print("✅ Célula 4: Componentes de compañeros (Stubs y MaquinaTAC) listos.")

# ================== PRUEBA TAC GENERATOR CON NUEVO AST ==================

def prueba_tac_generator():
    """Prueba tu TACGenerator con el nuevo formato de AST"""

    # Crea un AST simple en el nuevo formato
    ast_simple = Program([
        Assignment(
            Token('ID', 'x', 1),
            BinaryOp(
                Literal(Token('LITERAL_ENTERO', '5', 1)),
                Token('OP_ARIT', '+', 1),
                BinaryOp(
                    Literal(Token('LITERAL_ENTERO', '3', 1)),
                    Token('OP_ARIT', '*', 1),
                    Literal(Token('LITERAL_ENTERO', '2', 1))
                )
            )
        )
    ])

    print("AST de prueba:", ast_simple)

    # Genera TAC
    generator = TACGenerator()
    tac = generator.generate(ast_simple)

    print("\nTAC generado:")
    for instruction in tac:
        print(instruction)

# Ejecutar prueba
prueba_tac_generator()

# ================== 5. PIPELINE (Diego Bed) ==================
# (Tu parte - La "Línea de Ensamblaje")

def compilar(ruta_archivo_fuente, ruta_archivo_salida):
    """
    Función 'compile.py'. Implementa Etapas 1-4.
    """

    # 0. Instanciar componentes
    lexico = AnalizadorLexico()
    semantico = AnalizadorSemanticoAST() # El STUB
    generador_tac = GeneradorDeCodigo() # El STUB

    print(f"--- Iniciando compilación de: {ruta_archivo_fuente} ---")

    # 1. Leer el código fuente COMPLETO
    try:
        with open(ruta_archivo_fuente, 'r', encoding='utf-8') as file:
            codigo_completo = file.read()
    except FileNotFoundError:
        print(f"Error: No se encontró el archivo '{ruta_archivo_fuente}'")
        return False

    # --- ETAPA 1: LÉXICO ---
    print("\n--- ETAPA 1: LÉXICO ---")
    tokens = lexico.tokenizar(codigo_completo)
    print(f"Tokens generados: {len(tokens)}")

    # --- ETAPA 2: SINTÁCTICO (Parser) ---
    print("\n--- ETAPA 2: SINTÁCTICO (Parser) ---")
    try:
        parser = AnalizadorSintactico(tokens)
        ast = parser.parse()
        print("Árbol de Sintaxis Abstracto (AST) generado exitosamente.")
    except SystemExit:
        print("Compilación detenida por error sintáctico.")
        return False
    except Exception as e:
        print(f"Error Sintáctico Fatal Inesperado: {e}")
        return False

    # --- ETAPA 3: SEMÁNTICO ---
    print("\n--- ETAPA 3: SEMÁNTICO ---")
    semantico.analizar(ast) # Llama al STUB
    print("Análisis semántico simulado completado.")

    # --- ETAPA 4: GENERACIÓN DE CÓDIGO (TAC) ---
    print("\n--- ETAPA 4: GENERACIÓN DE CÓDIGO (TAC) ---")
    codigo_tac = generador_tac.generar(ast) # Llama al STUB
    print("Código TAC simulado generado exitosamente.")

    with open(ruta_archivo_salida, "w", encoding='utf-8') as f:
        f.write(codigo_tac)
    print(f"Código TAC guardado en: {ruta_archivo_salida}")

    print("\n--- Compilación Finalizada Exitosamente ---")
    return True


def ejecutar(ruta_archivo_tac, maquina_tac_real):
    """
    Función 'run.py'. Implementa Etapa 5.
    """
    print(f"\n--- ETAPA 5: EJECUCIÓN (Runtime) ---")
    print(f"Usando la MaquinaTAC de tu compañero (Rol 3).")

    try:
        with open(ruta_archivo_tac, 'r') as f:
            contenido_tac = f.read()
            print(f"Contenido de {ruta_archivo_tac} que se ejecutaría:\n{contenido_tac}")

            # (Simulación de ejecución)
            # El Rol 3 necesitará una función que convierta el
            # string 'contenido_tac' en la lista de 'instrucciones'
            instrucciones_falsas = [('assign', 't1', 10), ('assign', 't2', 5)]
            maquina_tac_real.ejecutar(instrucciones_falsas)
            print("[Simulación] Se llamó a maquina_tac.ejecutar() con instrucciones falsas.")

    except FileNotFoundError:
        print(f"Error: No se encontró el archivo TAC '{ruta_archivo_tac}'")

print("✅ Célula 5: Funciones del Pipeline (compilar/ejecutar) listas.")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile ejemplo.txt
# // Archivo de prueba para el compilador
# 
# int x;
# int y;
# 
# x = 10;
# y = 5;
# 
# print(x);
# 
# if (x > y) {
#     print(1);
# } else {
#     print(0);
# }
# 
# while (x > 0) {
#     x = x - 1;
# }

# ================== 7. PUNTO DE ENTRADA ==================

if __name__ == "__main__":

    archivo_fuente = "ejemplo.txt"
    archivo_tac_salida = "output.tac"

    # --- INICIA TU ROL (COMPILACIÓN) ---
    compilacion_exitosa = compilar(archivo_fuente, archivo_tac_salida)

    # --- INICIA EL ROL DE TU COMPAÑERO (EJECUCIÓN) ---
    if compilacion_exitosa:
        vm_real = MaquinaTAC()
        ejecutar(archivo_tac_salida, vm_real)
    else:
        print("\nLa ejecución fue omitida debido a errores de compilación.")